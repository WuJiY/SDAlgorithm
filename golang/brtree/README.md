

# 概序
   在二叉树,其增删查改随着树的高度的变化,而变化,其复杂度为O(h),所以当树的高度比较高时,有可能其速度还不如链表来的快, 而红黑树能保证这些在时间复杂度为O(lgn)
   红黑树本质上是一颗二叉搜索树,而能保证任何一条路径的长度都不会比其他的路径多2倍, 因此也可以看做是某种意义上的近似平衡吧
# 实现
    1. 红黑树中的每个节点都包含以下属性
        (1) color 非红即黑
        (2) key   关键字  
        (3) value 与关键字所对应的值
        (4) left 左结点
        (5) right 右结点
    2. 如果一个结点没有左右或者父结点,那么对应的属性值为nil
    3. 根结点是黑色的
    4. 每个nil结点是黑色的
    5. 如果一个结点是红色的,那么他的两个子结点都是黑色的
    6. 这是平衡的要点, 也就是从根结点到叶结点所经历的黑色节点数目是相同的
    7. 高度计算2lg(n+1), 至多
# 功能实现
     插入 : 功能实现和二叉树都差不多只不过需要注意6种情况
     1. 插入结点的叔结点是红色
     2. 插入结点的叔结点是黑色，有左孩子
     3. 插入结点的叔结点是黑色,有右孩子 
    而插入结点的父结点是红色是左孩子还是右结点
    所以一共6中情况
     删除: 和二叉树的相差不大,不过着色点,为插入结点的左结点或者右结点,亦或者是后继结点的右结点
      只不过着色的时候有8种情况, 因为是对称的,对称情况是,着色点是左结点还是右结点,且着色点是黑色的时候才会去进行着色处理
      1. 着色点的兄弟结点是红色
      2. 着色点的兄弟结点是黑色,且该兄弟的两个子结点都是黑色
      3. 着色点的兄弟结点的是左孩子是红色, 右孩子是黑色
      4. 兄弟结点是黑色, w的右孩子是红色
    



     





